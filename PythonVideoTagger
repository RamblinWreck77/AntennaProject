# /// one app to rule them all

__author__='Eric Pate'
# Date: Many long days in summer 2014

##### feasible TO DO LIST:


##### Exploration TO-DO LIST:
# AI tagging (lol)
# invent time machine
#####
#
## version checking
wrongVersion=0                                       # 0= good
##
### Functional importing
#
import time                                          # for holding/pausing python for X number of seconds
import copy                                          # for var isolation
import re                                            # regex string matchng
import threading                                     # threading module, used for the video rendering loop
import xml.etree.ElementTree as ET                   # XML import, we'll be using XML for our database
import codecs                                        # used in XML database import/parsing
import sys                                           # used for version checking
#
### Use tkinter for tag Database management GUI
#
import tkinter                                       # GUI package for the user interface/selection methods
from tkinter import *                                #
from tkinter import messagebox                       # how we do pop-up notifications
from tkinter import filedialog                       # how we ask the user for files/locations
#
### NON-STANDARD PYTHON MODULES
#
try:
    import pexpect                                   # module for handling Command-Line-Interfaces (CLI)
    import pysrt                                     # module for parsing subtitles
except:
    messagebox.showerror('Missing Module', 'The "pexpect" module was not found and is required to run this program! Please install on your system to continue!')
    wrongVersion=1                                   # set wrong version to true and don't run
#
####
#
#
#### PYTHON VERSION CHECKING BELOW
#
comp=sys.version[0]                                  # Pull python version string
if comp!='3':                                        # if we get any other version than 3 error out
    wrongVersion=1                                   # set wrong version to true and don't run
#
####
#
#
####>>> GLOBAL VAR SETUP
#
data = {}                                            # GLOBAL DATABASE FUNCTION == {'tag name':[t1,t2,t3...],'tag2 name':[t1,t2,t3...]}
timeCode=0                                           # GLOBAL timecode var, used for how many seconds the movie is at
PlayPause=0                                          # 1=playing 0=paused
currentTagNumber=-1                                  # for seeking bewteen TIME tags, how we know which one we're on when skipping forward/backwards
title=''                                             # name of video file
fileLoc=''                                           # path to file
currentTagName=''                                    # the name of the tag we've currently selected
videoIsLoaded=0                                      # flag saying YES, we have actually laoded a video
tagsIndexGUI=[]                                      # will hold a sorted list, will have the order tags appear in listerT, the main tag list
needToSeek=0                                         # flag to let movie thread know we need to perform a seek
newSeekTime=0                                        # holding var for the calculated new seek time (gets figured out before it's sent to movie thread)
#
####>>> END GLOBAL VARS
if wrongVersion==0:
    #
    ######>>> DATABASE CLASS
    #
    class Database:                                                 # an external class for the purpose of modifying the global tag dictionary
        #
        def exchange(self,tag,time):                                # method that will be called by other classes to interact with database
            time=int(time)
            #
            if tag!='':                                 # if "new" isn't empty, append it to Db and return. Weakness: Every call MUST include a new value even if it's null
                global data
                imp = copy.deepcopy(data)                           # make a copy of current Db
                #
                ### Duplicate detection and tag insertion block
                #
                try: # key exists case
                    imp[tag]                                        # test if key exists
                    temp = imp[tag]                                 # create holding var, should = [t1,t2,t3]
                    ### check if time code exists already
                    matching=[item for item in temp if time==item]
                    if len(matching)==0:                            # no matches found
                        temp2 = temp+[time]                         # add on new time code, should =[t1,t2,t3,new]
                        imp[tag] = temp2                            # replace key with new combined value
                        #
                    #### if not then don't do anything, the tag's time codes will be passed back to itself.
                    #
                except: # key doesn't exist
                    imp[tag] = [time]
                #
                ###
                ## ENFORCE ASCENDING TIME CODES HERE
                vecs=imp[tag]
                vecs.sort()                         # logic to find tags and force-sort them
                ##
                appender = imp                      # pre-export holding
                #
                data = appender
                #
            return data                             #return the database to the thing that asked for it properly updated AND sorted
    #
    ######<<<
    #
    ######>>> USER INTERFACE CLASS
    #
    class UI(tkinter.Tk,Database):
        #
        def __init__(self,parent):                             # __init__ is the default method that runs @ start, responsible for creating GUI and tying buttons/key presses to separate functions/methods
            #
            tkinter.Tk.__init__(self)                          # initialize tkinter graphics
            #
            self.updater=StringVar()                           #
            #
            #
            self.grid()
            ## Var initialization
            self.texter = tkinter.StringVar()                   # string holding var for the tag name typed by the user in the tag input box
            self.timer = tkinter.StringVar()                    # string holding var for the tag's time code
            self.searcher = tkinter.StringVar()                 # string holding var for searching tag Database, this is what the user is searching for
            ##
            #
            self.L1 = tkinter.Label(text = "Tag Entry (hit enter): ")                                           # Label
            self.L1.grid(column=0,row=0)
            #
            self.tagEntry = tkinter.Entry(width=50,textvariable=self.texter)                                    # Entry field for tag name
            self.tagEntry.grid(column=1,row=0,columnspan=3)
            self.tagEntry.bind("<KeyRelease-Return>", self.EnterPressed)                                        # bind the box to the Enter Key being released, call Db write method
            #
            self.PlayMovieButton = tkinter.Button(width=20,text='Open Video File', command=self.OpenMovie)      # Open Video file button, calls Open movie method that gets the file name/location from user
            self.PlayMovieButton.grid(column=0,row=3,columnspan=1)
            #
            self.PauseMovieButton = tkinter.Button(width=20,text='Play/Pause Movie', command=self.PauseMovie)   # Pause button, calls PauseMovie method which tells VLC to stop/start playback
            self.PauseMovieButton.grid(column=2,row=3,sticky='w')
            #
            self.skipBackButton = tkinter.Button(width=20,text='Skip Back', command=lambda:self.Skip(-7))       # A button for jumping the movie back a few seconds because you couldn't type the tag gast enough. NOTE: command=lambda{} is used here as self.METHOD() tries to run on init, and self.Skip needs input paramenters. lambda forces python to wait for a click to run.
            self.skipBackButton.grid(column=3,row=3,sticky='e')
            #
            self.L2 = tkinter.Label(text = "Tag Search (hit enter): ")                                          # Label
            self.L2.grid(column=0,row=4)
            #
            self.tagSearch = tkinter.Entry(width=40,textvariable=self.searcher)                                 # Tag Database search text entry box
            self.tagSearch.grid(column=0,row=5)
            self.tagSearch.bind("<KeyRelease-Return>", self.SearchDb)
            #
            self.Ltt = tkinter.Label(text = "Tag Times (sec): ")                                                # Tag Time List Label
            self.Ltt.grid(column=4,row=4,sticky='n')
            #
            self.Lt = tkinter.Label(text = "All Tags: ")                                                        # Current tag list label
            self.Lt.grid(column=2,row=4,sticky='n')
            #
            self.Lt = tkinter.Label(text = "Tags Found: ")                                                      # Tags found matching your search
            self.Lt.grid(column=3,row=4,sticky='n')
            #
            self.Import = tkinter.Button(width=40,text='Import Database',command=lambda: self.importXML(1))             #< we sent "import" with the write-flag set to 1 (write) here because we want our direct import function to write to database immediately.
            self.Import.grid(column=0,row=7)
            #
            self.Export = tkinter.Button(width=40,text='Export Database',command=self.exportXML)                        #<
            self.Export.grid(column=0,row=8)
            #
            self.Mergeer = tkinter.Button(width=40,text='Merge Database',command=self.mergeXML)                         #< XML IMPORT/EXPORT/MERGE buttons
            self.Mergeer.grid(column=0,row=9)
            #
            ### REFUGEE CENTER FOR LIST GUI TRANSFER
            ## seek buttons
            self.SeekTagForward = tkinter.Button(width=15,text='Skip Forwards >>',command=lambda: self.SeekTags('Forwards',(1)))    # basically create the "seek by tag" buttons, commands have lambdas as tkinter commands w/parameters auto-execute on init without them. Dumb.
            self.SeekTagForward.grid(column=0,row=6,sticky='e')
            self.SeekTagBackward = tkinter.Button(width=15,text='<< Skip Backwards',command=lambda: self.SeekTags('Backwards',(-1)))
            self.SeekTagBackward.grid(column=0,row=6,sticky='w')
            ## All Tags List
            self.TagsList=Listbox(None)                                                   # list object to display tags
            self.TagsList.grid(column=2,row=5)                                              # make the list as large as it needs to be
            #
            ## Tags that match your search list
            self.SearchResultsList = Listbox(None)
            self.SearchResultsList.grid(column=3,row=5)
            #
            ## Time codes that match the selected tag list
            self.TimeCodesList=Listbox(None)                                                  # list object to display tags
            self.TimeCodesList.grid(column=4,row=5)       # make the list as large as it needs to be, ADD SCROLL LATER
            dataSorted=copy.deepcopy(list(data.keys()))                                 # make a copy of the Db Keys
            dataSorted.sort()                                                           # sort them alphabetically for the GUI
            tagsIndexGUI=dataSorted                                                     # pass sorted values back to global tag list var
            for item in dataSorted:                                                     # write the list to be every tag we currently have in the Db
                self.TimeCodesList.insert(END,item)                                               # Insert @ end of list each tag as we go through iteration
            ##
            ### END REF CENTER #thisWillTakeForeverToFix
        #
        def deleteTime(self,misc):                                          # A method we call to delete time codes from a tag
            ## GLOBAL Variables
            global data
            global currentTagName
            ##
            tup=self.TimeCodesList.curselection()                                  # gets the user selected item from list, is form tuple (why? Idk)
            try:                                                            # Try to delete time code entry
                indexer=int(tup[0])                                             # conv to integer. Indexer is now the index of the time we wish to delete
                timeToDelete=self.TimeCodesList.get(indexer)                           # fetch the real value (from the list) for what we want to delete
                NewTime=copy.deepcopy(data[currentTagName])                     # isolate copy from the main Db, new time should be the time vector for that tag [1,2,3,4,etc]
                NewTime.remove(timeToDelete)                                    # remove the time code we've selected
                data[currentTagName]=NewTime                                    # make the tag in the Db's vector = the new vector, having removed the value.
                self.TimeCodesList.delete(indexer)                                     # delete element from list in teh GUI now that it is gone from Db
                ## was the time we just deleted the last one? If so we'll delete the entire tag. Check below
                length=len(self.TimeCodesList.get(0,END))
                if length==0:                                               # if the tag list is now empty
                    self.deleteTag('current')                                   # call delete tag function with flag "current", aka the tag is now out of time codes so delete the tag entry
                ##
            except:
                messagebox.showerror('Nothing Selected','You must select an item to delete it. Click a value and hit delete again.')        # Because someone will always try to delete nothing
        #
        def deleteTag(self,flag):                                       # flag is if we delete the tag the user has clicked OR the last known current tag
            ## GLOBAL Variables
            global data                                                     # main database
            global currentTagName                                           # name of the tag in listerT we're working with
            global tagsIndexGUI                                             # ordered list of all tags, find the index in this list and it's the index in the listerT GUI
            ##
            if flag=='current':                                         # this conditional gets run when deleteTime realizes it just deleted the last time code that entry has
                indexer=[item for item, v in enumerate(tagsIndexGUI) if v==currentTagName][0]  # returns index of current tag in TagsList
                tagToDelete=self.TagsList.get(indexer)                       # fetch the real value (from the list) for what we want to delete
                data.pop(tagToDelete,None)
                self.TagsList.delete(indexer)                                # delete element from list in the GUI now that it is gone from Db
                #
            if flag=='clicked':                                         # this is the normal delete tag command, it deletes the tag the user has clicked in the tag list
                tup=self.TagsList.curselection()                             # gets the user selected item from list, is type==tuple.
                try:                                                        # try case just in case they hit the delete key but haven't selected anything
                    indexer=int(tup[0])                                     # conv to integer. Indexer is now the index of the time we wish to delete
                    tagToDelete=self.TagsList.get(indexer)                   # fetch the real value (from the list) for what we want to delete
                    data.pop(tagToDelete,None)
                    self.TagsList.delete(indexer)                            # delete element from list in the GUI now that it is gone from Db
                    #
                except:
                    messagebox.showerror('Nothing Selected','You must select an item to delete it. Click a value and hit delete again.')
            self.refreshTagList()                                   # after we delete stuff rebuild list
            #
        #
        def refreshTagList(self):                                       # whenever we update the database via any method, just call this to rebuild the current tag list. Also handles ALL BINDING
            ## GLOBAL vars
            global data
            global currentTagName
            global tagsIndexGUI
            ##
            ## CURRENT TAG LIST UPDATING
            #
            if len(data)>0:                                                                     # SWITCH: Is the database empty? If so do nothing
                self.TagsList.delete(0,END)                                                         # zero out list
                dataSorted=copy.deepcopy(list(data.keys()))                                         # make a copy of the Db Keys
                dataSorted.sort()                                                                   # sort them alphabetically for the GUI
                tagsIndexGUI=dataSorted                                                             # pass sorted values back to global tag list var
                for item in dataSorted:                                                             # write the list to be every tag we currently have in the Db
                    self.TagsList.insert(END,item)                                             # Insert @ end of list each tag as we go through iteration
                ## BINDINGS
                self.TagsList.bind('<Double-Button-1>',self.tagListClicked)                       # Double Click OR enter binds to the Current Tag list, as well as Delete/BackSpace calls remove item
                self.TagsList.bind('<KeyRelease-Return>',self.tagListClicked)                     #
                self.TagsList.bind('<BackSpace>',lambda event: self.deleteTag('clicked'))      # clicked flag == what the cursor is currently selecting
                ##
            else:                                                                                 # Database must be empty, do nothing
                qq=1
            #
            ## CURRENT SEARCH RESULTS LIST REFRESH
            #
            i=0
            try:                                                                               # TRY to refresh search results if search results exist
                while i<len(self.Results):                                                       # WHILE: we go through all of our results from the Regex Search
                    self.SearchResultsList.insert(END,self.Results[i])
                    i=i+1
            except:
                qq=1
            self.SearchResultsList.delete(0,END)                                                  # list is populated by the seach function, each refresh should wipe it
            self.SearchResultsList.bind('<KeyRelease-Return>',self.searchResultsClicked)
            self.SearchResultsList.bind('<Double-Button-1>',self.searchResultsClicked)
            #
            ## CURRENT TIME LIST REFRESH
            #
            self.TimeCodesList.delete(0,END)
            self.TimeCodesList.bind('<Double-Button-1>',self.timeCodeListClicked)                # BIND Tag Time selection to Double click & Enter, and delete
            self.TimeCodesList.bind('<KeyRelease-Return>',self.timeCodeListClicked)              #
            self.TimeCodesList.bind('<BackSpace>',self.deleteTime)                               #
            try:                                                                                # TRY To refresh time codes lists they exist
                times=data[currentTagName]                                                      # fetch time codes
                for item in times:
                    self.TimeCodesList.insert(END,item)
            except:
                qq=1
            #
            ##
        #
        def EnterPressed(self,misc):            # method to react to the enter key being hit: 1.send tag to database exchange method
            ## GLOBAL VAR IMPORT
            global timeCode
            global data
            global currentTagName
            global videoIsLoaded
            ##
            ## FETCH DB INFO BELOW
            if videoIsLoaded==1:                                                        # MAKE SURE we loaded a video before trying to send tags to the database
                PreTextInput=self.texter.get()                                          # Pre-fetch the input value from the class var, make instanced var for filtering purposes
                #
                ## FILTER INPUT BELOW
                err=0                                                                   # this will be our error flag for filtering, if it fails fitlering anywhere error out and notify user
                #
                ## >> Filter rules: 1. tags must be all lowercase 2. no numbers 3. no special characters {a-z} only
                #
                textInput=PreTextInput.lower()                                          # MAKE ALL ELEMENTS IN THE TAG LOWERCASE (irony)
                matches=re.findall(r'\d',textInput)                                     # regex for any digits in input
                if len(matches)>0:                                                      # if the result of the regex has any elements then numbers were found
                    err=1                                                                   # trip error flag
                    #
                matches=re.findall(r'\W',textInput)                                     # find any NON [A-Z] chars (except _)
                if len(matches)>0:
                    err=1                                                                   # trip error flag
                    #
                if len(textInput)==0:                                                   # make sure the text input isn't blank
                    err=1                                                                   # trip error flag
                ## FILTER INPUT ABOVE
                #
                if err==0:                                                              # if NONE of those tests threw an error flag continue
                    keeeys=data.keys()                                                      # pull all active keys in database
                    keysM=[item for item in keeeys if item==textInput]                      # make a vector of tag matches in Db, should be len()=0 if it's a new tag
                    ##### NOTE: This fetch needed to happen before the Database gets updated, else how would the check logic know it's a new tag? (for the GUI Updated list)
                    ##
                    print('Database is ',Database().exchange(str(textInput),str(timeCode)))                # print to screen and write to DB at the same time ##swag Printing is for debug purposes
                    ##
                    currentTagName=textInput                                                # update global var for current tag name with input so other methods know whats up
                    ##  this is to force the SearchDb func to build the time lists
                    self.searcher.set(textInput)                                            # in order to get the time code list to BUILD currently we need a successful search, so this sets the search field to what we entered (and already submitted) so the time code list GUI gets built.
                    ##                                                                      # LOGIC: Tag entry -> DB, while this instantly searches Db to update current tag list so list updates for user *as they add* tags.
                    self.SearchDb('misc')
                    self.refreshTagList()                                                   # rebuild all our tags in the time list, we just updated it so the list should reflect these changes
                    self.SearchResultsList.delete(0,END)
                    self.SearchResultsList.insert(END,textInput)
                    self.texter.set('')                                                     # clear the input field after we've taken it
                    self.searcher.set('')                                                   # clear the search field instantly, hide the evidence!
                    #
                else:
                    messagebox.showerror('Invalid Tag',"Looks like you've used some funny characters or tried to submit a blank tag, please use only letters or '_'! \n \n \nDismiss this box by clicking 'ok' not hitting enter, otherwise you'll just submit a blank tag again. ")
                    self.texter.set('')                                                     # clear tag entry field after they messed up.
                    #
            else:
                messagebox.showerror('No File',"You can't add tags to nothing, please hit 'Open Movie' to load a video file!")              # becayse you can't tag about nothing, duh (unless you're a teenager on twitter)
                self.texter.set('')
                #                                                                                                                           # clear the input field
        #
        def movieThread(self):                          # Ok, so for lots of reasons the method running the video needs to be in its own thread looping continuously. Just trust me.
            ## GLOBAL VAR imports
            global PlayPause                            # GLOBAL play/pause status. Watch this for changes
            global currentTagNumber                     # GLOBAL seek status, watch this for changes!
            global fileLoc                              # where the file we're opening is stored
            global data                                 # main database
            global timeCode                             # global var for the current time code, updated by this methof as we fetch from VLC's CLI
            global needToSeek                           # a flag that, when changed, says "hey we need to seek somewhere so look for the newSeekTime value!!"
            global newSeekTime                          # a new "destination" time calculated by the Skip method, when needToSeek gets flipped this is the time the movie thread (this) tells VLC to jump to
            ##
            # VLC *Command *Line *Interface init below:
            video=pexpect.spawnu('/Applications/VLC.app/Contents/MacOS/VLC')            # spawn a child CLI to talk to VLC
            time.sleep(.1)                                                              # wait a bit for VLC to respond, slowpoke
            orderTemplate='add '                                                        # the syntax is "add_xxxPathToFilexxx"
            order=orderTemplate+fileLoc                                                 # the order to send to VLC's CLI
            video.sendline(order)                                                       # send this command to the VLC CLI, for now it's static
            video.logfile = open("/Users/ericpate/Desktop/log.txt", "w")
            video.maxread=1                                                             # not 100% sure I need this, but I think it maxes line reads to 1 at time. This is good if true.
            #
            while True:                                     # movie is perma-looping in this thread
                #### EXTERNAL CONTROL VAR CHECK
                #
                ### External control var creation, if switch vars don't exist create them.
                #
                try:                                            # if play/pause switch exists do nothing
                    self.switch
                except:                                         # if it doesn't exist create it and make it equal to the current global var value
                    self.switch=PlayPause                           # play/pause toggle switch
                try:                                            # if previous seek index switch doesn't exist create it, NEW: Make class var so other methods can force a re-seek by making the OldSeek==-1
                    self.OldSeek                                    # the index of the tag we last tried to seek to
                except:                                         # if the var didn't exist create it and set it equal to the current tag number
                    self.OldSeek=currentTagNumber
                try:                                            # if var exists do nothing
                    self.previousSeekState                          # a binary flag letting this thread (movie thread) know it needs to check the global var newSeekTime for a seek order
                except:                                         # if it doesn't exist create it and make it equal to the current needToSeek state (so no flagging occurs)
                    self.previousSeekState=needToSeek
                #
                ### END external control var creation
                #
                ## Now ACT UPON control variable changes if they get flipped by outside methods
                #
                try:                                            # IF we have a database up try and build a list of indexes for our current tags every loop through
                    self.codes=data[currentTagName]
                except:                                         # do nothing
                    qq=1
                #
                if PlayPause!=self.switch:                      # SWITCH: Did we get told to pause? If so tell VLC to pause
                    video.sendline('pause')                         # IMPORTANT: pause.... pause... actually pauses then plays. It's a toggle.
                    self.switch=PlayPause                           # reset switch var so it doesn't keep tripping
                    #
                if currentTagNumber!=self.OldSeek:              # SWITCH: Did we get told to seek to a tag? If so fetch the timecode for that tag and seek to it.
                    temp=(self.codes[currentTagNumber])             # fetch the actual tag from the tag list via index
                    if temp<0:                                      # IF temp<0 make it 0, as you can't seek to a negative value (I hope)
                        temp=0
                    order='seek '+str(temp)                         # create the seek order string
                    video.sendline(order)                           # send the 'seek XXX' order where XXX=seconds == from the tag
                    time.sleep(0.2)                                 # wait for a bit so VLC can process
                    self.OldSeek=currentTagNumber                   # reset switch var
                    #
                if needToSeek!=self.previousSeekState:          # SWITCH: Did we get told to skip to a certain time? If so tell VLC to seek to pre-calculated time.
                    order='seek '+str(newSeekTime)                  # order= 'seek 12345' where 1234=seconds, newSeekTime is calculated in "skip" method
                    video.sendline(order)                           # send order to VLC CLI
                    time.sleep(0.2)                                 # wait for a but so VLC can process
                    self.previousSeekState=needToSeek               # reset switch var
                    #
                #
                #### END EXTERNAL CONTROL VAR CHECK
                #
                ## Fetch current video timecode from VLC and record Below
                video.sendline('get_time')                      # ask VLC what time the movie is at
                time.sleep(0.1)                                 # wait
                video.expect('\n+')                             # epect a "newline" char
                time.sleep(0.1)                                 # wait
                tt=video.readline()                             # read result
                ## Conditional waiting
                matches=re.findall('get_time',tt)               # if we get a bad read wait and read again, don't want to end up reading what we just sent to VLC
                if len(matches)>0:                              # VLC's output should never match our command syntax, so if there's a match in our command syntax in the response keep polling until we get a sensible answer (aka an integer time value)
                    time.sleep(0.1)                                 # wait
                    tt=video.readline()                             # READ LINE AGAIN
                ##
                try:
                    timeCode=int(tt)                            # try to convert the timecode string to an integer
                except:
                    qq=1                                        # if that fails do nothing, impossible-to-convert timecodes don't get recorded
                #
                ## sleep:
                time.sleep(0.05)                                # end loop and wait this long before running again
        #
        def OpenMovie(self):        # helper function tied to the open movie GUI button, makes a thread of the video function, also generates title of content to be used later (like naming the exported Db)
            ## GLOBAL VARS
            global fileLoc                                                          # global var for exact file location
            global title                                                            # global var for title, based on file name of input!
            global videoIsLoaded                                                    # global var telling other methods that yes we actually loaded a video
            ##
            name=filedialog.askopenfilename()                                       # ask the user for the video file
            fileLoc=name                                                            # export user-selected file name to global variable for other methods to see
            ## MP4 CHECK BELOW
            fileType=fileLoc[-4:]                                                   # you better have an ".mp4" in your file path or I'm gonna be mad. Last 4 chars in path should be ".mp4"
            if fileType=='.mp4':                                                    # SWITCH: Do the last 4 chars of the file path == '.mp4'?
                fileType=1                                                              # all clear flag
            ##
            if fileLoc!='' and fileType==1:                                         # If they didn't enter a file name OR it's not an .mp4 STOP HERE
                ## Regex to find FILE TITLE HERE
                searcher=re.findall(r'/\w+\.\w+',name)                                  # look for file name of video selected: aka Desktop/Nemesis.mp4 => returns /Nemesis.mp4, need to clean
                #
                if len(searcher)>0:                                                     # only do this if our search object found something
                    target=searcher[0]                                                      # extract result, *should only be one*
                    target=target[1:]                                                       # remove the first character (a slash)
                    title=target                                                            # pass title to GLOBAL VAR
                    app.title('Video Tagging Interface'+' : '+title)                        # Update app name with the file name
                    videoIsLoaded=1                                                         # let everything else know we laoded a video file

                else:
                    messagebox.showerror('Error','Unable to determine file name for some reason. File this as a bug and send me the file path of the file you tried to load. File Title (and Database export) will be DefaultDb')
                    title='DefaultDb'                                                       # general non-critical error, give Db a default name and keep going. Can't imagine why this would happen though... probably regex mistake
                ##
                # Threading of video execution below, this launches the indpendant VIDEO PLAYER thread
                ##
                threads = []                                                        # thread holding list, but we only need 1 (for now.... I hope...)
                for i in range(1):                                                  # holding var + thread initiation, the video render has to be run in it's own thread
                    t = threading.Thread(target=self.movieThread)                   # threading module targets the movie thread process for thread separatation hastag #mainEngineStart
                    threads.append(t)                                               # add to list of threads
                    t.start()                                                       # liftoff
            else:
                if fileLoc=='':                                                                                                                         # if file path is empty
                    messagebox.showerror('No File','No File Selected, please select a file to continue!')
                if fileType!=1:                                                                                                                         # if we didn't get a success flag from file type check
                    messagebox.showerror('Wrong Video Type',"Currently only .MP4 files are supported, the video you tried to load wasn't an .MP4. Please try again!")
                else:                                                                                                                                   # general idk wtf happened message.
                    messagebox.showerror('Unknown','Unknown Error in the OpenMovie method, likely related to file selection.')
        #
        def PauseMovie(self):       # A method for setting the global play/plause var to zero so the loop knows to stop
            ## GLOBAL vars
            global PlayPause        # the play/pause flag. Each time this value changes the movie thread sees it and movie is either played or paused (whichever it isn't currently)
            global videoIsLoaded    # global flag saying we've loaded a video file successfully
            ##
            if videoIsLoaded==1:        # SWITCH: Did we load a video?
                #                           # Whatever PlayPause is switch it, this method does only get called when they click the Play/Pause button you know.
                if PlayPause==0:
                    PlayPause=1
                else:
                    PlayPause=0             # flippity-floppity
                #
            else:
                messagebox.showerror('No Video',"You cant play/pause a movie you haven't loaded! Please hit 'Open Movie' to load a video file.") # Because you can't pause nothing.
        #
        def SearchDb(self,misc):                  # function that searches database
            ## TO-DO (wow a lot... guess they better keep me around!)
            # I'd like to radically modify this function. First, Search should basically do the following:
            # 1. pull list of keys
            # X. do a search for exact matches, if so continue
            # X. if no exact found, then do a tag-by-tag regex for partial matches/fragments (google-esque search)
            # X. add a 3rd list, so what we have is (1): all tags (2): tags that match your search (3): time codes for tags that match your search ( need to update init method to include this)
            # X. Get the list builders in an entirely separate method, with ordered-pair paramenters
            # X. make lists permanent GUI items and use the actual delete() functiono
            # X. update refreshlist() accoridngly
            #
            # But for now it works... in a backwards way as it's actually responsible for nasty GUI construction and other should-have-abstracted stuff. Don't blame me I just wrote the thing (didn't know this would grow to this size)
            #
            ## GLOBAL VAR import
            global data                                                                 # global Db import
            global currentTagNumber                                                     # current tag INDEX
            global currentTagName                                                       # string name of current tag
            ##
            #
            keyer=self.searcher.get()                                                   # item we're searching for, aka the tag
            keyer=keyer.lower()                                                         # sanitize input to be all lowercase letters
            #
            if len(data)>0 and self.searcher.get()!='':                                 # SWITCH: IF we have a database AND IF we're not searching for nothing, continue
                try:                                                                        # first TRY TO CALL TAG IN DICT, if tag doesn't exist this will fail
                    #### FUTURE REGEX SEARCH CODE
                    self.Results=[]
                    keys=list(data.keys())                                                            # all the tags in our Database
                    for item in keys:                                                           # for each tag in our database
                        matches=re.findall(keyer,item)                                          # for every item in the key list, see if the user's input is IN that key somewhere
                        if matches!=[]:
                            self.Results=self.Results+[item]
                    currentTagName=self.searcher.get()                                          # did our search just succeed at finding a tag? Make sure we update the GLOBAL var so the other methods know this is the current tag
                    #### END FUTURE REGEX SEARCH CODE
                    #Results=[currentTagName]                                                    # old code, exact matches only
                    ## CLEAR SEARCH RESULTS AND TIMECODE LISTS BEFORE RE-POPULATING THEM
                    self.SearchResultsList.delete(0,END)
                    self.TimeCodesList.delete(0,END)
                    ##
                    i=0
                    while i<len(self.Results):                                                       # WHILE: we go through all of our results from the Regex Search
                        self.SearchResultsList.insert(END,self.Results[i])
                        i=i+1                                                                   # clock up
                    ## Iteration to build list

                    ## End iteration
                    #
                    ## TAG HIGHLIGHTING/SEEKING IN ALL-TAGS LIST
                    #
                    try:                                                                        # "try" highlights the tag you searched for in the list search had an IF EXACT MATCH
                        allStuff=self.TagsList.get(0,END)                                           # gets the list of tags in the TAG LIST type is TUPLE (x,y,x,...)
                        indexer=[item for item, v in enumerate(allStuff) if v==keyer][0]            # not sure exactly how this works, but it searches the tuple and returns the index of the key found within the tuple. the [0] just makes [1]->1
                        self.TagsList.select_clear(0,END)                                           # > make sure the thing we just searched for is visible AND highlighted
                        self.TagsList.see(indexer)                                                  # >
                        self.TagsList.select_set(indexer)                                           # >
                        self.TagsList.activate(indexer)                                             # > active
                    except:
                        qq=1                                                                    # do nothing
                    #
                    self.TimeCodesList.select_clear(0,END)
                    self.TimeCodesList.select_set(currentTagNumber)                             # HIGHLIGHTS the current tag
                    self.TimeCodesList.activate(currentTagNumber)                               # makes sure current tag is SELECTED (the black box)
                    ## End highlighting
                    self.searcher.set('')                                                       # clear search field
                    self.texter.set('')                                                         # clear tag field too, we're all done
                    self.SearchResultsList.bind('<KeyRelease-Return>',self.searchResultsClicked)
                    self.SearchResultsList.bind('<Double-Button-1>',self.searchResultsClicked)
                except:                                                                     # EXCEPT: so the tag wasn't in the dict
                    print('tag wasnt in dict')
                    self.TagsList.select_clear(0,END)                                           # >when a failed search happens CLEAR SELECTIONS IN ALL GUI LISTS
                    self.SearchResultsList.delete(0,END)                                        # >
                    self.TimeCodesList.select_clear(0,END)                                      # >
                    #
                    self.searcher.set('')                                                       # clear search field
                    self.texter.set('')                                                         # clear tag field too
                    #
            elif self.searcher.get()=='':                                              # SWITCH FAIL: So the tag we're searching for must have been empty
                self.TagsList.select_clear(0,END)                                            # when a failed search happens de-select tag in the tag window
                self.TimeCodesList.select_clear(0,END)                                            # when a failed search happens de-select tag in the tag window
                self.SearchResultsList.delete(0,END)                                        # when a failed search happens clear the search result list
                #
            else:                                                                      # SWITCH FAIL: If this happened it must mean len(data)==0 and there's no Database (or an empty one)
                self.searcher.set('')
                messagebox.showerror('No Database Found',"You can't search an empty database, please load a video and add tags or use the import button with a valid XML file.")
                #
        #
        def SeekTags(self,misc,index):                      # method to seek-by-tag # based on user input, should modify global variables / flags so movie thread knows what to do
            ## GLOBAL VAR IMPORT
            global currentTagNumber                             # global var for the INDEX of the current tag we're on. AKA if tags are ['A','B','C'] and we're on tag A then currentTagNumber is 0 (zero index)
            ##
            # index parameter sent to this function is the NEW INDEX DIRECTION OF TRAVEL relative to orginal index
            #
            if videoIsLoaded==1 and currentTagName!='' and len(data)>0:
                NewTagNum=currentTagNumber+index                    # (a holding var) = (old index from global) + (1) forward or (-1) backward depending on which seek button gets hit, passed in by parameter "index"
                #
                if NewTagNum<0:                                     # SWITCH: we need to filter tag indexes. We can't seek to [-1] in the tag list etc
                    NewTagNum=0                                         # if tag index # <0 then set to 0.
                    self.OldSeek=-1                                     # set self.OldSeek to -1. Why? Check out the movie thread. It filters the -1 result as a Zero. So if keep skipping back from the zero tag it'll just "stick" on the zero tag as intended.
                    #
                if NewTagNum>len(self.codes)-1:                     # SWITCH: if the new tag goes past the end of the list then we need to seek back
                    NewTagNum=len(self.codes)-1                         # if tag index goes past the last tag then jump back to last tag.
                    self.OldSeek=-1                                     # trigger seek flag again so movie thread reacts.
                    #
                currentTagNumber=NewTagNum                              # update global var with the new tag index
                self.TimeCodesList.select_clear(0,END)                  # > TIME CODE slection/highlighting on seek
                self.TimeCodesList.activate(currentTagNumber)           # >
                self.TimeCodesList.select_set(currentTagNumber)         # >
            else:
                messagebox.showerror("Can't Seek",'Please load a video, select/build a database, and select a tag so use the seek button!')
        #
        def importXML(self,flag):                                   # a function for importing (and replacing) the current database with that which came from an XML file, flag== WRITE, 1=write 0=Do Not Write
            ## GLOBAL VAR IMPORT
            global data
            global title
            global videoIsLoaded
            ##
            NewData={}                                             # empty Db to be populated as we deconstruct the XML file
            incomp=0
            ##
            if videoIsLoaded==1:                                   # SWITCH: Did we even load a video? IF so continue
                opener=filedialog.askopenfilename()                    # ask the user where the XML database file they want to import is on their computer
                #
                if opener!='' and opener[-3:]=='xml':                      # STOP if no file is selected OR file is not even an XML file
                    try:                                                   # TRY to load file, if this fails then it's a mal-formed XML
                        raw=codecs.open(opener,'r','utf-8')                    # import the raw bytes
                        form=ET.parse(raw)                                     # try to interprit the bytes into readable XML
                        root=form.getroot()                                    # now extract the XML tree from the parsed file
                        ## NAME-MATCH FILTERING BELOW
                        raw=str(root)                                          # the root of the imported XML in a string '<element 'name' >'
                        matches=re.findall(title,raw)                          # look for the video file name in that string, if not there then matches will be []
                        ## END NAME-MATCH FILTERING
                        #
                        ## CRYPTO KEEP CHECK BELOW
                        secure=re.findall(r'--AxTecfhaJUshanAASLKJnqQPIYNasvaApQNnAMNSg',raw)       # super-s3cr3t crypto tag, not foolproof just stops you from accidently telling the app to import some random XML file.
                        ## END CRYPTO KEY CHECK
                        #
                        if len(matches)>0 and len(secure)>0:                   # SWITCH: IF find the movie name in the XML AND the crypto key is there then continue, otherwise error
                            # input file has passed ALL TESTS, parse to Db now
                            for child in root:                                     # go through the sub-elements in the XMl file, extract the tag names and time code vectors
                                StrVector=child.attrib['times']                        # grab the time code vector from the element's attribute list, though it's all one giant string...
                                numbers=re.findall(r'\d+',StrVector)                   # regex the numbers out of the string vector, numbers must be digits 1 or more digits long
                                IntVector=[]                                           # holding var for int vector
                                for item in numbers:                                   # for every item in time code list add them in integer form to the integer list
                                    IntVector=IntVector+[int(item)]
                                    #
                                NewData[child.tag]=IntVector                            # build the new database from the properly formatted data
                            #
                            if flag==1:                                                 # only actually write to Db if flag=1. Flag exists so merge can call import without wiping everything right away
                                data=NewData                                            # write imported Db to the global database var
                            ##
                            # Current Tags List updater POST IMPORT/MERGE below:
                            try:                                                        # TRY: to refresh the tag list, not critical that it happens here
                                self.refreshTagList()                                       # update tags in GUI
                            except:
                                qq=1
                            ##
                            return NewData                                              # if everything's good return the new database if asked for (aka by the merge function)
                        else:                                                 # SWITCH FAIL: Either the XML filename doesn't have the movie name in it OR it's missing crypto key.
                            if len(matches)==0:                                    # Video file name wasn't found in XML title, must not have been made from same file
                                messagebox.showerror('Incompatible Database',"It looks like the XML you're trying to import wasn't made from the video file you're trying to watch and therefore is incompatible. Please import a matching database made from the same file name or create a new one.")
                                incomp=1                                           # incompatible flag, to prevent double-notification
                                #
                            if len(secure)==0:                                     # Crypto key wasn't found in XML, must not have been made by this app
                                messagebox.showerror('Wrong XML',"This XML database wasn't made by this app. Please try to import an XML database that was!")
                                incomp=1                                           # flag incomp and alert user
                                #
                            self.refreshTagList()                                  # update stuff
                            error='err'                                            # define err var as a string, other methods that call import (aka merge) will be looking for this flag before proceeding.
                            return error                                           # return the error flag
                    except:
                        if incomp==0:                                              # only show this for general XML parse errors, don't display this error message when we simply failed verification
                            messagebox.showerror('XML Parsing Error',"Something went wrong when we tried to read this XML file, it appears to be broken. Please try another.")              # aka IDK what went wrong, but it happened up there ^
                        else:
                            qq=1                                                   # do nothing
                else:
                    messagebox.showerror('File Missing','Please select an XML database file to continue')
                    error='err'
                    return error                                                   # return the erorr flag so if we're merging the merge function knows to stop
            else:
                messagebox.showerror("No Video Loaded","Cannot import a database until a video has been loaded. Please hit 'Open Movie' and select a video file.")
                error='err'
                return error                                                       # return the erorr flag so if we're merging the merge function knows to stop
        #
        def exportXML(self):                                                            # a function for exporting the current database to an XML file
            ## GLOBAL VAR IMPORT
            global data
            global title
            ##
            if len(data)>0:                                                             # SWITCH: IF we have a database with stuff in it
                titler=(title+' Database XML.xml')                                          # the file name will just be the (Video Title) + (Database XML.xml)
                fileE=open(titler,'w')                                                      # creates the file in the same directory the python script runs in
                temp=data.keys()                                                            # fetch keys from the main database
                keys=[i for i in temp]                                                      # make keys into a vector/list
                #
                root=ET.Element(title+'--AxTecfhaJUshanAASLKJnqQPIYNasvaApQNnAMNSg')        # master element is name of file, add in crypto key for verification later
                ### XML GENERATION BELOW
                for item in keys:                                                           # FOR every item in the list of dictionary keys (tags)
                    sub=ET.SubElement(root,item)                                                # sub element is the tag name
                    tags=data[item]                                                             # fetch the timecode vector for that tag
                    sub.set('times',tags)                                                       # make the sub element (the tag name) have the attribs [list of time codes]
                    #
                tree=ET.ElementTree(root)                                                   # bundle everything for the XML constructor
                tree.write(titler)                                                          # FIRE THE WRITE CANNON
                messagebox.showerror('SUCCESS!','Current database was successfully exported to root folder, look for an XML file in the same location as your .py file.')
            else:
                messagebox.showinfo(None,'Cannot Export an empty database! Try adding some tags first.') # if there's no elements in the Database don't Export
                #
            ###
        #
        def mergeXML(self):                                       # A function for merging an Imported XML with your existing database
            ## GLOBAL VAR IMPORT
            global data
            global title
            ##
            NewData=self.importXML(0)                                # Call IMPORT methond w/write flag==0, aka do not write what you've imported to Db, just pass the new data along.
            if NewData!='err':
                CombDict={}                                                                         # holding var for the merged + De-Duped database, will expand this below
                PrevDict=copy.deepcopy(data)                                                        # Isolated copy or First Db for modification/iteration
                FIRSTtags=list(PrevDict.keys())                                                     # all tags in the FIRST database
                NEWtags=list(NewData.keys())                                                        # all tags in the NEW database
                #### IN first database only && either not in the NEW OR needs to be merged
                for item in FIRSTtags:                                                              # for every tag in the first Database
                    try:                                                                            # try to call that tag in the NewDatabase, if it exists we begin merging /DeDupe the time vector. If not this errors and we just add
                        NewData[item]                                                               # if this doesn't error then that means the old AND new Dbs have that tag. Now we must merge the time vectors
                        t1=PrevDict[item]                                                           # should be time vectors aka ['1','2','3'] etc for each
                        t2=NewData[item]
                        #
                        tExc=[item for item in t1 if item not in t2]                                # which time codes appear in t1 that are NOT in t2? =tExclusive
                        t3=t2+tExc                                                                  # combine #2 with all the things in #1 (and not in 2) and it SHOULD be a de-duplicated combination of the two
                        t3.sort()                                                                   # now time codes are sorted ascending
                        CombDict[item]=t3                                                           # send to the combined dictionary
                    except:
                        sorter=PrevDict[item]                                                       # Security sort, just incase we missed something and inputs aren't sorted ascending
                        sorter.sort()                                                               #
                        CombDict[item]=sorter                                                       # if the tag in the old Dict wasn't found in the new one, we can just add the Old Dict's data to the combined one

                #### In file but NOT in orginal database period (this and previous case should cover all, I think...)
                adder=[item for item in NEWtags if item not in FIRSTtags]                           # this should be all the tags that are in our new Db that weren't in the old one, should be able to directly add
                for item in adder:
                    CombDict[item]=NewData[item]                                                    # for every tag in adder, create that tag in combined dictionary and the values from the NewData's dict (constructed from import, aka NEWtags's values
                #   # [item for item in b if item not in a]

                print('Database Successfully Merged')
                data=CombDict                                                                       # export to GLOBAL DATABASE

                self.refreshTagList()                                                               # update current list of tags in GUI
                ##
        #
        def timeCodeListClicked(self,idk):
            global currentTagNumber
            global currentTagName
            #
            try:                                                                            # TRY TO SEEK based on selection, if errors it's because a time code is selected, not a tag in the list, when you hit enter
                stringer=self.TimeCodesList.curselection()                                        # returns a tuple with the index of what the user clicked on, is form ('n',0)
                indexer=int(stringer[0])                                                          # get the index from the returned tuple and make int so we can use it, aka ('n',0) -> n
                print(indexer)
                currentTagNumber=indexer                                                          # the time code # to pull from, aka what we pass to searcher/seeker
                self.buildTimeList()                                                              # make sure we rebuild the time code list when we're done
                self.SeekTags('misc',0)                                                           # now run the actual seek function
                self.OldSeek=-1
                #
            except:
                qq=1
        #
        def tagListClicked(self,misc):                                  # a method to order SEEK time codes by clicking them
            ## Global Vars
            global currentTagNumber                                     # global var for the INDEX of the current Tag TIME CODE for that Tag
            global currentTagName                                       # global var for the NAME of the current tag selected
            ##
            tup=self.TagsList.curselection()                            # get the tuple back of the list index
            try:
                indexer=tup[0]
                stringer=self.TagsList.get(indexer)
                # pass back to global vars
                currentTagName=stringer                                     # update global var for current tag name
                currentTagNumber=-1                                         # make global var for timecode # -1, will get filtered to 0
                #
                self.searcher.set(currentTagName)                           # set search field TEXT to the current tag (that we just clicked) so the SearchDb method pulls it in
                self.SearchDb('misc')                                       # we clicked a tag from the ALL TAGS list, pass this info to SearchDb so it populates our TAGS FOUND List
                self.buildTimeList()
                self.SeekTags('misc',0)                                     # Search DB SHOULD have populated TAGS FOUND list, so now call SEEK TAGS to jump to location of the first timecode associated with that tag
            except:
                qq=1
        #
        def searchResultsClicked(self,misc):
            ## GLobal Vars
            global currentTagName                                                           # CURRENT TAG
            ##
            tup=self.SearchResultsList.curselection()                                       # grab the current selected item from the search result list
            try:
                indexer=tup[0]                                                                  # grab the index from the tupel response
                stringer=self.SearchResultsList.get(indexer)                                    # get the name of the item @ that index in list
                currentTagName=stringer                                                         # push to global var
                currentTagNumber=-1                                                             # reset "current Tag Number" so movie thread notices and performs an update, is -1 so movie thread sees as new AND filters to zero
                #
                self.buildTimeList()                                                            # update time list
                self.SeekTags('misc',0)                                                         # have seek tags run based on this
                self.OldSeek=-1
            except:
                qq=1
                #
        #
        def Skip(self,SkipBy):                                                                  # a function for skipping around by specific amounts FROM CURRENT time
            ## GLOBAL VARS
            global timeCode                             # the time the video is currently at
            global newSeekTime                          # a holding var for passing the new seek time to the movie thread
            global needToSeek                           # a binary int we flip every time we want to seek, movie thread is watching this for changes
            ##
            temp=timeCode+SkipBy                        # newSeekTime=(time video is at)+(the skip value). Skip value in most cases is -7s from the "skip back button" but this method supports any amound
            if temp<0:
                qq=1                                    # seek filtering, make sure we can't tell VLC to seek to a negative time value! Probably should include some type of forward seek protection... if they extend my internship I'll add this
            else:
                newSeekTime=temp                        # ONLY if we have a valid seek-back do we pass to newSeekTime, here we pass the calculated time to the global var
                #
                ## Flag below
                if needToSeek==0:                       # now that we've calculated our new seek-time and passed it to global vars flip the flag so the movie thread knows to make changes, CONDITIONAL on valid seek time
                    needToSeek=1
                else:
                    needToSeek=0
            ##

        def buildTimeList(self):                                                        # a method to re-populate the list of time codes in the timeCodesList GUI list element
            self.codes=data[currentTagName]                                                    # store the time codes for this tag in a class var for inspection later aka [t1,t2,t3....]
            timer=len(self.codes)                                                       # how many tags we found
            i=0                                                                         # clock var for while loop
            self.TimeCodesList.delete(0,END)                                            # clear entry before we start
            while i<timer:                                                              # WHILE: basically count up through the time codes found and add to TIME CODES LIST
                self.TimeCodesList.insert(END,self.codes[i])                                # add on
                i=i+1
            self.TimeCodesList.bind('<KeyRelease-Return>',self.timeCodeListClicked)     # ensure our lists get the BIND command every time we rebuild them.
            self.TimeCodesList.bind('<Double-Button-1>',self.timeCodeListClicked)


    #
    ######<<< END USER INTERFACE CLASS
    #
    app = UI(None)
    app.title('Video Tagging Interface'+' : '+title)
    app.configure(background='grey')
    app.mainloop()

    #/Applications/VLC.app/Contents/MacOS/VLC
    #add /Users/ericpate/Desktop/Dale Proj/Nemesis.mp4

    # crypto: AxTecfhaJUshanAASLKJnqQPIYNasvaApQNnAMNSg

    # subtitle open path: subs=pysrt.open('/Users/ericpate/Desktop/Dale Proj/Dale Video/Star Trek 10 Nemesis DVDRip.srt', encoding='iso-8859-1')

else:
    print('Incompatible Version of Python, please upgrade to python 3 and install pexpect module!')







